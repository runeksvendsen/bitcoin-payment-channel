-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Streaming data processing library.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/conduit</a>.
--   
--   <tt>conduit</tt> is a solution to the streaming data problem, allowing
--   for production, transformation, and consumption of streams of data in
--   constant memory. It is an alternative to lazy I/O which guarantees
--   deterministic resource handling, and fits in the same general solution
--   space as <tt>enumerator</tt>/<tt>iteratee</tt> and <tt>pipes</tt>. For
--   a tutorial, please visit
--   <a>https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview</a>.
@package conduit
@version 1.2.6.1

module Data.Conduit.Internal.Fusion

-- | This is the same as stream fusion's Step. Constructors are renamed to
--   avoid confusion with conduit names.
data Step s o r
Emit :: s -> o -> Step s o r
Skip :: s -> Step s o r
Stop :: r -> Step s o r
data Stream m o r
Stream :: (s -> m (Step s o r)) -> (m s) -> Stream m o r
data ConduitWithStream i o m r
type StreamConduitM i o m r = Stream m i () -> Stream m o r
type StreamConduit i m o = StreamConduitM i o m ()
type StreamSource m o = StreamConduitM () o m ()
type StreamProducer m o = forall i. StreamConduitM i o m ()
type StreamSink i m r = StreamConduitM i Void m r
type StreamConsumer i m r = forall o. StreamConduitM i o m r
streamConduit :: ConduitM i o m r -> (Stream m i () -> Stream m o r) -> ConduitWithStream i o m r
streamSource :: Monad m => Stream m o () -> ConduitWithStream i o m ()
streamSourcePure :: Monad m => Stream Identity o () -> ConduitWithStream i o m ()
unstream :: ConduitWithStream i o m r -> ConduitM i o m r
instance GHC.Base.Functor (Data.Conduit.Internal.Fusion.Step s o)

module Data.Conduit.Internal.List.Stream
unfoldS :: Monad m => (b -> Maybe (a, b)) -> b -> StreamProducer m a
unfoldMS :: Monad m => (b -> m (Maybe (a, b))) -> b -> StreamProducer m a
sourceListS :: Monad m => [a] -> StreamProducer m a
enumFromToS :: (Enum a, Ord a, Monad m) => a -> a -> StreamProducer m a
enumFromToS_int :: (Integral a, Monad m) => a -> a -> StreamProducer m a
iterateS :: Monad m => (a -> a) -> a -> StreamProducer m a
replicateS :: Monad m => Int -> a -> StreamProducer m a
replicateMS :: Monad m => Int -> m a -> StreamProducer m a
foldS :: Monad m => (b -> a -> b) -> b -> StreamConsumer a m b
foldMS :: Monad m => (b -> a -> m b) -> b -> StreamConsumer a m b
mapM_S :: Monad m => (a -> m ()) -> StreamConsumer a m ()
dropS :: Monad m => Int -> StreamConsumer a m ()
takeS :: Monad m => Int -> StreamConsumer a m [a]
headS :: Monad m => StreamConsumer a m (Maybe a)
mapS :: Monad m => (a -> b) -> StreamConduit a m b
mapMS :: Monad m => (a -> m b) -> StreamConduit a m b
iterMS :: Monad m => (a -> m ()) -> StreamConduit a m a
mapMaybeS :: Monad m => (a -> Maybe b) -> StreamConduit a m b
mapMaybeMS :: Monad m => (a -> m (Maybe b)) -> StreamConduit a m b
catMaybesS :: Monad m => StreamConduit (Maybe a) m a
concatS :: (Monad m, Foldable f) => StreamConduit (f a) m a
concatMapS :: Monad m => (a -> [b]) -> StreamConduit a m b
concatMapMS :: Monad m => (a -> m [b]) -> StreamConduit a m b
concatMapAccumS :: Monad m => (a -> accum -> (accum, [b])) -> accum -> StreamConduit a m b
mapAccumS :: Monad m => (a -> s -> (s, b)) -> s -> StreamConduitM a b m s
mapAccumMS :: Monad m => (a -> s -> m (s, b)) -> s -> StreamConduitM a b m s
concatMapAccumMS :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> StreamConduit a m b
mapFoldableS :: (Monad m, Foldable f) => (a -> f b) -> StreamConduit a m b
mapFoldableMS :: (Monad m, Foldable f) => (a -> m (f b)) -> StreamConduit a m b
consumeS :: Monad m => StreamConsumer a m [a]
groupByS :: Monad m => (a -> a -> Bool) -> StreamConduit a m [a]
groupOn1S :: (Monad m, Eq b) => (a -> b) -> StreamConduit a m (a, [a])
data GroupByState a b s
GBStart :: s -> GroupByState a b s
GBLoop :: ([a] -> [a]) -> a -> b -> s -> GroupByState a b s
GBDone :: GroupByState a b s
groupBy1S :: Monad m => (a -> b) -> (b -> b -> Bool) -> StreamConduit a m (a, [a])
isolateS :: Monad m => Int -> StreamConduit a m a
filterS :: Monad m => (a -> Bool) -> StreamConduit a m a
sinkNullS :: Monad m => StreamConsumer a m ()
sourceNullS :: Monad m => StreamProducer m a

module Data.Conduit.Internal

-- | The underlying datatype for all the types in this package. In has six
--   type parameters:
--   
--   <ul>
--   <li><i>l</i> is the type of values that may be left over from this
--   <tt>Pipe</tt>. A <tt>Pipe</tt> with no leftovers would use
--   <tt>Void</tt> here, and one with leftovers would use the same type as
--   the <i>i</i> parameter. Leftovers are automatically provided to the
--   next <tt>Pipe</tt> in the monadic chain.</li>
--   <li><i>i</i> is the type of values for this <tt>Pipe</tt>'s input
--   stream.</li>
--   <li><i>o</i> is the type of values for this <tt>Pipe</tt>'s output
--   stream.</li>
--   <li><i>u</i> is the result type from the upstream <tt>Pipe</tt>.</li>
--   <li><i>m</i> is the underlying monad.</li>
--   <li><i>r</i> is the result type.</li>
--   </ul>
--   
--   A basic intuition is that every <tt>Pipe</tt> produces a stream of
--   output values (<i>o</i>), and eventually indicates that this stream is
--   terminated by sending a result (<i>r</i>). On the receiving end of a
--   <tt>Pipe</tt>, these become the <i>i</i> and <i>u</i> parameters.
--   
--   Since 0.5.0
data Pipe l i o u m r

-- | Provide new output to be sent downstream. This constructor has three
--   fields: the next <tt>Pipe</tt> to be used, a finalization function,
--   and the output value.
HaveOutput :: (Pipe l i o u m r) -> (m ()) -> o -> Pipe l i o u m r

-- | Request more input from upstream. The first field takes a new input
--   value and provides a new <tt>Pipe</tt>. The second takes an upstream
--   result value, which indicates that upstream is producing no more
--   results.
NeedInput :: (i -> Pipe l i o u m r) -> (u -> Pipe l i o u m r) -> Pipe l i o u m r

-- | Processing with this <tt>Pipe</tt> is complete, providing the final
--   result.
Done :: r -> Pipe l i o u m r

-- | Require running of a monadic action to get the next <tt>Pipe</tt>.
PipeM :: (m (Pipe l i o u m r)) -> Pipe l i o u m r

-- | Return leftover input, which should be provided to future operations.
Leftover :: (Pipe l i o u m r) -> l -> Pipe l i o u m r

-- | Wait for a single input value from upstream.
--   
--   Since 0.5.0
await :: Pipe l i o u m (Maybe i)

-- | This is similar to <tt>await</tt>, but will return the upstream result
--   value as <tt>Left</tt> if available.
--   
--   Since 0.5.0
awaitE :: Pipe l i o u m (Either u i)

-- | Wait for input forever, calling the given inner <tt>Pipe</tt> for each
--   piece of new input. Returns the upstream result type.
--   
--   Since 0.5.0
awaitForever :: Monad m => (i -> Pipe l i o r m r') -> Pipe l i o r m r

-- | Send a single output value downstream. If the downstream <tt>Pipe</tt>
--   terminates, this <tt>Pipe</tt> will terminate as well.
--   
--   Since 0.5.0
yield :: Monad m => o -> Pipe l i o u m ()
yieldM :: Monad m => m o -> Pipe l i o u m ()

-- | Similar to <tt>yield</tt>, but additionally takes a finalizer to be
--   run if the downstream <tt>Pipe</tt> terminates.
--   
--   Since 0.5.0
yieldOr :: Monad m => o -> m () -> Pipe l i o u m ()

-- | Provide a single piece of leftover input to be consumed by the next
--   pipe in the current monadic binding.
--   
--   <i>Note</i>: it is highly encouraged to only return leftover values
--   from input already consumed from upstream.
--   
--   Since 0.5.0
leftover :: l -> Pipe l i o u m ()

-- | Perform some allocation and run an inner <tt>Pipe</tt>. Two guarantees
--   are given about resource finalization:
--   
--   <ol>
--   <li>It will be <i>prompt</i>. The finalization will be run as early as
--   possible.</li>
--   <li>It is exception safe. Due to usage of <tt>resourcet</tt>, the
--   finalization will be run in the event of any exceptions.</li>
--   </ol>
--   
--   Since 0.5.0
bracketP :: MonadResource m => IO a -> (a -> IO ()) -> (a -> Pipe l i o u m r) -> Pipe l i o u m r

-- | Add some code to be run when the given <tt>Pipe</tt> cleans up.
--   
--   Since 0.4.1
addCleanup :: Monad m => (Bool -> m ()) -> Pipe l i o u m r -> Pipe l i o u m r

-- | The identity <tt>Pipe</tt>.
--   
--   Since 0.5.0
idP :: Monad m => Pipe l a a r m r

-- | Compose a left and right pipe together into a complete pipe. The left
--   pipe will be automatically closed when the right pipe finishes.
--   
--   Since 0.5.0
pipe :: Monad m => Pipe l a b r0 m r1 -> Pipe Void b c r1 m r2 -> Pipe l a c r0 m r2

-- | Same as <a>pipe</a>, but automatically applies <a>injectLeftovers</a>
--   to the right <tt>Pipe</tt>.
--   
--   Since 0.5.0
pipeL :: Monad m => Pipe l a b r0 m r1 -> Pipe b b c r1 m r2 -> Pipe l a c r0 m r2

-- | Run a pipeline until processing completes.
--   
--   Since 0.5.0
runPipe :: Monad m => Pipe Void () Void () m r -> m r

-- | Transforms a <tt>Pipe</tt> that provides leftovers to one which does
--   not, allowing it to be composed.
--   
--   This function will provide any leftover values within this
--   <tt>Pipe</tt> to any calls to <tt>await</tt>. If there are more
--   leftover values than are demanded, the remainder are discarded.
--   
--   Since 0.5.0
injectLeftovers :: Monad m => Pipe i i o u m r -> Pipe l i o u m r

-- | Fuse together two <tt>Pipe</tt>s, connecting the output from the left
--   to the input of the right.
--   
--   Notice that the <i>leftover</i> parameter for the <tt>Pipe</tt>s must
--   be <tt>Void</tt>. This ensures that there is no accidental data loss
--   of leftovers during fusion. If you have a <tt>Pipe</tt> with
--   leftovers, you must first call <a>injectLeftovers</a>.
--   
--   Since 0.5.0
(>+>) :: Monad m => Pipe l a b r0 m r1 -> Pipe Void b c r1 m r2 -> Pipe l a c r0 m r2

-- | Same as <a>&gt;+&gt;</a>, but reverse the order of the arguments.
--   
--   Since 0.5.0
(<+<) :: Monad m => Pipe Void b c r1 m r2 -> Pipe l a b r0 m r1 -> Pipe l a c r0 m r2

-- | See <tt>catchC</tt> for more details.
--   
--   Since 1.0.11
catchP :: (MonadBaseControl IO m, Exception e) => Pipe l i o u m r -> (e -> Pipe l i o u m r) -> Pipe l i o u m r

-- | The same as <tt>flip catchP</tt>.
--   
--   Since 1.0.11
handleP :: (MonadBaseControl IO m, Exception e) => (e -> Pipe l i o u m r) -> Pipe l i o u m r -> Pipe l i o u m r

-- | See <tt>tryC</tt> for more details.
--   
--   Since 1.0.11
tryP :: (MonadBaseControl IO m, Exception e) => Pipe l i o u m r -> Pipe l i o u m (Either e r)

-- | Transform the monad that a <tt>Pipe</tt> lives in.
--   
--   Note that the monad transforming function will be run multiple times,
--   resulting in unintuitive behavior in some cases. For a fuller
--   treatment, please see:
--   
--   
--   <a>https://github.com/snoyberg/conduit/wiki/Dealing-with-monad-transformers</a>
--   
--   This function is just a synonym for <a>hoist</a>.
--   
--   Since 0.4.0
transPipe :: Monad m => (forall a. m a -> n a) -> Pipe l i o u m r -> Pipe l i o u n r

-- | Apply a function to all the output values of a <tt>Pipe</tt>.
--   
--   This mimics the behavior of <a>fmap</a> for a <tt>Source</tt> and
--   <tt>Conduit</tt> in pre-0.4 days.
--   
--   Since 0.4.1
mapOutput :: Monad m => (o1 -> o2) -> Pipe l i o1 u m r -> Pipe l i o2 u m r

-- | Same as <a>mapOutput</a>, but use a function that returns
--   <tt>Maybe</tt> values.
--   
--   Since 0.5.0
mapOutputMaybe :: Monad m => (o1 -> Maybe o2) -> Pipe l i o1 u m r -> Pipe l i o2 u m r

-- | Apply a function to all the input values of a <tt>Pipe</tt>.
--   
--   Since 0.5.0
mapInput :: Monad m => (i1 -> i2) -> (l2 -> Maybe l1) -> Pipe l2 i2 o u m r -> Pipe l1 i1 o u m r

-- | Convert a list into a source.
--   
--   Since 0.3.0
sourceList :: Monad m => [a] -> Pipe l i a u m ()

-- | Returns a tuple of the upstream and downstream results. Note that this
--   will force consumption of the entire input stream.
--   
--   Since 0.5.0
withUpstream :: Monad m => Pipe l i o u m r -> Pipe l i o u m (u, r)
enumFromTo :: (Enum o, Eq o, Monad m) => o -> o -> Pipe l i o u m ()

-- | Generalize the upstream return value for a <tt>Pipe</tt> from unit to
--   any type.
--   
--   Since 1.1.5
generalizeUpstream :: Monad m => Pipe l i o () m r -> Pipe l i o u m r

-- | Core datatype of the conduit package. This type represents a general
--   component which can consume a stream of input values <tt>i</tt>,
--   produce a stream of output values <tt>o</tt>, perform actions in the
--   <tt>m</tt> monad, and produce a final result <tt>r</tt>. The type
--   synonyms provided here are simply wrappers around this type.
--   
--   Since 1.0.0
newtype ConduitM i o m r
ConduitM :: (forall b. (r -> Pipe i i o () m b) -> Pipe i i o () m b) -> ConduitM i o m r
[unConduitM] :: ConduitM i o m r -> forall b. (r -> Pipe i i o () m b) -> Pipe i i o () m b

-- | Provides a stream of output values, without consuming any input or
--   producing a final result.
--   
--   Since 0.5.0
type Source m o = ConduitM () o m ()

-- | A component which produces a stream of output values, regardless of
--   the input stream. A <tt>Producer</tt> is a generalization of a
--   <tt>Source</tt>, and can be used as either a <tt>Source</tt> or a
--   <tt>Conduit</tt>.
--   
--   Since 1.0.0
type Producer m o = forall i. ConduitM i o m ()

-- | Consumes a stream of input values and produces a final result, without
--   producing any output.
--   
--   <pre>
--   type Sink i m r = ConduitM i Void m r
--   </pre>
--   
--   Since 0.5.0
type Sink i = ConduitM i Void

-- | A component which consumes a stream of input values and produces a
--   final result, regardless of the output stream. A <tt>Consumer</tt> is
--   a generalization of a <tt>Sink</tt>, and can be used as either a
--   <tt>Sink</tt> or a <tt>Conduit</tt>.
--   
--   Since 1.0.0
type Consumer i m r = forall o. ConduitM i o m r

-- | Consumes a stream of input values and produces a stream of output
--   values, without producing a final result.
--   
--   Since 0.5.0
type Conduit i m o = ConduitM i o m ()

-- | A <tt>Source</tt> which has been started, but has not yet completed.
--   
--   This type contains both the current state of the <tt>Source</tt>, and
--   the finalizer to be run to close it.
--   
--   Since 0.5.0
data ResumableSource m o
ResumableSource :: (Pipe () () o () m ()) -> (m ()) -> ResumableSource m o

-- | A generalization of <a>ResumableSource</a>. Allows to resume an
--   arbitrary conduit, keeping its state and using it later (or finalizing
--   it).
--   
--   Since 1.0.17
data ResumableConduit i m o
ResumableConduit :: (Pipe i i o () m ()) -> (m ()) -> ResumableConduit i m o

-- | Provide for a stream of data that can be flushed.
--   
--   A number of <tt>Conduit</tt>s (e.g., zlib compression) need the
--   ability to flush the stream at some point. This provides a single
--   wrapper datatype to be used in all such circumstances.
--   
--   Since 0.3.0
data Flush a
Chunk :: a -> Flush a
Flush :: Flush a

-- | A wrapper for defining an <a>Applicative</a> instance for
--   <a>Source</a>s which allows to combine sources together, generalizing
--   <a>zipSources</a>. A combined source will take input yielded from each
--   of its <tt>Source</tt>s until any of them stop producing output.
--   
--   Since 1.0.13
newtype ZipSource m o
ZipSource :: Source m o -> ZipSource m o
[getZipSource] :: ZipSource m o -> Source m o

-- | A wrapper for defining an <a>Applicative</a> instance for <a>Sink</a>s
--   which allows to combine sinks together, generalizing <a>zipSinks</a>.
--   A combined sink distributes the input to all its participants and when
--   all finish, produces the result. This allows to define functions like
--   
--   <pre>
--   sequenceSinks :: (Monad m)
--             =&gt; [Sink i m r] -&gt; Sink i m [r]
--   sequenceSinks = getZipSink . sequenceA . fmap ZipSink
--   </pre>
--   
--   Note that the standard <a>Applicative</a> instance for conduits works
--   differently. It feeds one sink with input until it finishes, then
--   switches to another, etc., and at the end combines their results.
--   
--   This newtype is in fact a type constrained version of
--   <a>ZipConduit</a>, and has the same behavior. It's presented as a
--   separate type since (1) it historically predates <tt>ZipConduit</tt>,
--   and (2) the type constraining can make your code clearer (and thereby
--   make your error messages more easily understood).
--   
--   Since 1.0.13
newtype ZipSink i m r
ZipSink :: Sink i m r -> ZipSink i m r
[getZipSink] :: ZipSink i m r -> Sink i m r

-- | Provides an alternative <tt>Applicative</tt> instance for
--   <tt>ConduitM</tt>. In this instance, every incoming value is provided
--   to all <tt>ConduitM</tt>s, and output is coalesced together. Leftovers
--   from individual <tt>ConduitM</tt>s will be used within that component,
--   and then discarded at the end of their computation. Output and
--   finalizers will both be handled in a left-biased manner.
--   
--   As an example, take the following program:
--   
--   <pre>
--   main :: IO ()
--   main = do
--       let src = mapM_ yield [1..3 :: Int]
--           conduit1 = CL.map (+1)
--           conduit2 = CL.concatMap (replicate 2)
--           conduit = getZipConduit $ ZipConduit conduit1 &lt;* ZipConduit conduit2
--           sink = CL.mapM_ print
--       src $$ conduit =$ sink
--   </pre>
--   
--   It will produce the output: 2, 1, 1, 3, 2, 2, 4, 3, 3
--   
--   Since 1.0.17
newtype ZipConduit i o m r
ZipConduit :: ConduitM i o m r -> ZipConduit i o m r
[getZipConduit] :: ZipConduit i o m r -> ConduitM i o m r

-- | Wait for a single input value from upstream. If no data is available,
--   returns <tt>Nothing</tt>. Once <tt>await</tt> returns
--   <tt>Nothing</tt>, subsequent calls will also return <tt>Nothing</tt>.
--   
--   Since 0.5.0
await :: Monad m => Consumer i m (Maybe i)

-- | Wait for input forever, calling the given inner component for each
--   piece of new input. Returns the upstream result type.
--   
--   This function is provided as a convenience for the common pattern of
--   <tt>await</tt>ing input, checking if it's <tt>Just</tt> and then
--   looping.
--   
--   Since 0.5.0
awaitForever :: Monad m => (i -> ConduitM i o m r) -> ConduitM i o m ()

-- | Send a value downstream to the next component to consume. If the
--   downstream component terminates, this call will never return control.
--   If you would like to register a cleanup function, please use
--   <a>yieldOr</a> instead.
--   
--   Since 0.5.0
yield :: Monad m => o -> ConduitM i o m ()
yieldM :: Monad m => m o -> ConduitM i o m ()

-- | Similar to <a>yield</a>, but additionally takes a finalizer to be run
--   if the downstream component terminates.
--   
--   Since 0.5.0
yieldOr :: Monad m => o -> m () -> ConduitM i o m ()

-- | Provide a single piece of leftover input to be consumed by the next
--   component in the current monadic binding.
--   
--   <i>Note</i>: it is highly encouraged to only return leftover values
--   from input already consumed from upstream.
--   
--   Since 0.5.0
leftover :: i -> ConduitM i o m ()

-- | Run a pipeline until processing completes.
--   
--   Since 1.2.1
runConduit :: Monad m => ConduitM () Void m r -> m r

-- | Connect a <tt>Source</tt> to a <tt>Sink</tt> until the latter closes.
--   Returns both the most recent state of the <tt>Source</tt> and the
--   result of the <tt>Sink</tt>.
--   
--   We use a <tt>ResumableSource</tt> to keep track of the most recent
--   finalizer provided by the <tt>Source</tt>.
--   
--   Since 0.5.0
connectResume :: Monad m => ResumableSource m o -> Sink o m r -> m (ResumableSource m o, r)

-- | Connect a <a>ResumableConduit</a> to a sink and return the output of
--   the sink together with a new <a>ResumableConduit</a>.
--   
--   Since 1.0.17
connectResumeConduit :: Monad m => ResumableConduit i m o -> Sink o m r -> Sink i m (ResumableConduit i m o, r)

-- | Similar to <tt>fuseReturnLeftovers</tt>, but use the provided function
--   to convert downstream leftovers to upstream leftovers.
--   
--   Since 1.0.17
fuseLeftovers :: Monad m => ([b] -> [a]) -> ConduitM a b m () -> ConduitM b c m r -> ConduitM a c m r

-- | Same as normal fusion (e.g. <tt>=$=</tt>), except instead of
--   discarding leftovers from the downstream component, return them.
--   
--   Since 1.0.17
fuseReturnLeftovers :: Monad m => ConduitM a b m () -> ConduitM b c m r -> ConduitM a c m (r, [b])

-- | The connect-and-resume operator. This does not close the
--   <tt>Source</tt>, but instead returns it to be used again. This allows
--   a <tt>Source</tt> to be used incrementally in a large program, without
--   forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Mnemonic: connect + do more.
--   
--   Since 0.5.0
($$+) :: Monad m => Source m a -> Sink a m b -> m (ResumableSource m a, b)

-- | Continue processing after usage of <tt>$$+</tt>.
--   
--   Since 0.5.0
($$++) :: Monad m => ResumableSource m a -> Sink a m b -> m (ResumableSource m a, b)

-- | Complete processing of a <tt>ResumableSource</tt>. This will run the
--   finalizer associated with the <tt>ResumableSource</tt>. In order to
--   guarantee process resource finalization, you <i>must</i> use this
--   operator after using <tt>$$+</tt> and <tt>$$++</tt>.
--   
--   Since 0.5.0
($$+-) :: Monad m => ResumableSource m a -> Sink a m b -> m b

-- | Left fusion for a resumable source.
--   
--   Since 1.0.16
($=+) :: Monad m => ResumableSource m a -> Conduit a m b -> ResumableSource m b

-- | The connect-and-resume operator. This does not close the
--   <tt>Conduit</tt>, but instead returns it to be used again. This allows
--   a <tt>Conduit</tt> to be used incrementally in a large program,
--   without forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Leftover data returned from the <tt>Sink</tt> will be discarded.
--   
--   Mnemonic: connect + do more.
--   
--   Since 1.0.17
(=$$+) :: Monad m => Conduit a m b -> Sink b m r -> Sink a m (ResumableConduit a m b, r)

-- | Continue processing after usage of <a>=$$+</a>. Connect a
--   <a>ResumableConduit</a> to a sink and return the output of the sink
--   together with a new <a>ResumableConduit</a>.
--   
--   Since 1.0.17
(=$$++) :: Monad m => ResumableConduit i m o -> Sink o m r -> Sink i m (ResumableConduit i m o, r)

-- | Complete processing of a <a>ResumableConduit</a>. This will run the
--   finalizer associated with the <tt>ResumableConduit</tt>. In order to
--   guarantee process resource finalization, you <i>must</i> use this
--   operator after using <a>=$$+</a> and <a>=$$++</a>.
--   
--   Since 1.0.17
(=$$+-) :: Monad m => ResumableConduit i m o -> Sink o m r -> Sink i m r

-- | The connect operator, which pulls data from a source and pushes to a
--   sink. If you would like to keep the <tt>Source</tt> open to be used
--   for other operations, use the connect-and-resume operator <a>$$+</a>.
--   
--   Since 0.4.0
($$) :: Monad m => Source m a -> Sink a m b -> m b

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0
($=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0
(=$) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r

-- | Fusion operator, combining two <tt>Conduit</tt>s together into a new
--   <tt>Conduit</tt>.
--   
--   Both <tt>Conduit</tt>s will be closed when the newly-created
--   <tt>Conduit</tt> is closed.
--   
--   Leftover data returned from the right <tt>Conduit</tt> will be
--   discarded.
--   
--   Since 0.4.0
(=$=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r
sourceToPipe :: Monad m => Source m o -> Pipe l i o u m ()
sinkToPipe :: Monad m => Sink i m r -> Pipe l i o u m r
conduitToPipe :: Monad m => Conduit i m o -> Pipe l i o u m ()

-- | Generalize a <a>Source</a> to a <a>Producer</a>.
--   
--   Since 1.0.0
toProducer :: Monad m => Source m a -> Producer m a

-- | Generalize a <a>Sink</a> to a <a>Consumer</a>.
--   
--   Since 1.0.0
toConsumer :: Monad m => Sink a m b -> Consumer a m b

-- | Perform some allocation and run an inner component. Two guarantees are
--   given about resource finalization:
--   
--   <ol>
--   <li>It will be <i>prompt</i>. The finalization will be run as early as
--   possible.</li>
--   <li>It is exception safe. Due to usage of <tt>resourcet</tt>, the
--   finalization will be run in the event of any exceptions.</li>
--   </ol>
--   
--   Since 0.5.0
bracketP :: MonadResource m => IO a -> (a -> IO ()) -> (a -> ConduitM i o m r) -> ConduitM i o m r

-- | Add some code to be run when the given component cleans up.
--   
--   The supplied cleanup function will be given a <tt>True</tt> if the
--   component ran to completion, or <tt>False</tt> if it terminated early
--   due to a downstream component terminating.
--   
--   Note that this function is not exception safe. For that, please use
--   <a>bracketP</a>.
--   
--   Since 0.4.1
addCleanup :: Monad m => (Bool -> m ()) -> ConduitM i o m r -> ConduitM i o m r

-- | Catch all exceptions thrown by the current component of the pipeline.
--   
--   Note: this will <i>not</i> catch exceptions thrown by other
--   components! For example, if an exception is thrown in a
--   <tt>Source</tt> feeding to a <tt>Sink</tt>, and the <tt>Sink</tt> uses
--   <tt>catchC</tt>, the exception will <i>not</i> be caught.
--   
--   Due to this behavior (as well as lack of async exception handling),
--   you should not try to implement combinators such as
--   <tt>onException</tt> in terms of this primitive function.
--   
--   Note also that the exception handling will <i>not</i> be applied to
--   any finalizers generated by this conduit.
--   
--   Since 1.0.11
catchC :: (MonadBaseControl IO m, Exception e) => ConduitM i o m r -> (e -> ConduitM i o m r) -> ConduitM i o m r

-- | The same as <tt>flip catchC</tt>.
--   
--   Since 1.0.11
handleC :: (MonadBaseControl IO m, Exception e) => (e -> ConduitM i o m r) -> ConduitM i o m r -> ConduitM i o m r

-- | A version of <tt>try</tt> for use within a pipeline. See the comments
--   in <tt>catchC</tt> for more details.
--   
--   Since 1.0.11
tryC :: (MonadBaseControl IO m, Exception e) => ConduitM i o m r -> ConduitM i o m (Either e r)

-- | Transform the monad that a <tt>ConduitM</tt> lives in.
--   
--   Note that the monad transforming function will be run multiple times,
--   resulting in unintuitive behavior in some cases. For a fuller
--   treatment, please see:
--   
--   
--   <a>https://github.com/snoyberg/conduit/wiki/Dealing-with-monad-transformers</a>
--   
--   This function is just a synonym for <a>hoist</a>.
--   
--   Since 0.4.0
transPipe :: Monad m => (forall a. m a -> n a) -> ConduitM i o m r -> ConduitM i o n r

-- | Apply a function to all the output values of a <tt>ConduitM</tt>.
--   
--   This mimics the behavior of <a>fmap</a> for a <a>Source</a> and
--   <a>Conduit</a> in pre-0.4 days. It can also be simulated by fusing
--   with the <tt>map</tt> conduit from <a>Data.Conduit.List</a>.
--   
--   Since 0.4.1
mapOutput :: Monad m => (o1 -> o2) -> ConduitM i o1 m r -> ConduitM i o2 m r

-- | Same as <a>mapOutput</a>, but use a function that returns
--   <tt>Maybe</tt> values.
--   
--   Since 0.5.0
mapOutputMaybe :: Monad m => (o1 -> Maybe o2) -> ConduitM i o1 m r -> ConduitM i o2 m r

-- | Apply a function to all the input values of a <tt>ConduitM</tt>.
--   
--   Since 0.5.0
mapInput :: Monad m => (i1 -> i2) -> (i2 -> Maybe i1) -> ConduitM i2 o m r -> ConduitM i1 o m r

-- | Execute the finalizer associated with a <tt>ResumableSource</tt>,
--   rendering the <tt>ResumableSource</tt> invalid for further use.
--   
--   This is just a more explicit version of <tt>$$+- return ()</tt>.
--   
--   Since 1.1.3
closeResumableSource :: Monad m => ResumableSource m a -> m ()

-- | Unwraps a <tt>ResumableSource</tt> into a <tt>Source</tt> and a
--   finalizer.
--   
--   A <tt>ResumableSource</tt> represents a <tt>Source</tt> which has
--   already been run, and therefore has a finalizer registered. As a
--   result, if we want to turn it into a regular <tt>Source</tt>, we need
--   to ensure that the finalizer will be run appropriately. By
--   appropriately, I mean:
--   
--   <ul>
--   <li>If a new finalizer is registered, the old one should not be
--   called.</li>
--   <li>If the old one is called, it should not be called again.</li>
--   </ul>
--   
--   This function returns both a <tt>Source</tt> and a finalizer which
--   ensures that the above two conditions hold. Once you call that
--   finalizer, the <tt>Source</tt> is invalidated and cannot be used.
--   
--   Since 0.5.2
unwrapResumable :: MonadIO m => ResumableSource m o -> m (Source m o, m ())

-- | Unwraps a <tt>ResumableConduit</tt> into a <tt>Conduit</tt> and a
--   finalizer.
--   
--   Since <a>unwrapResumable</a> for more information.
--   
--   Since 1.0.17
unwrapResumableConduit :: MonadIO m => ResumableConduit i m o -> m (Conduit i m o, m ())

-- | Turn a <tt>Source</tt> into a <tt>ResumableSource</tt> with no
--   attached finalizer.
--   
--   Since 1.1.4
newResumableSource :: Monad m => Source m o -> ResumableSource m o

-- | Turn a <tt>Conduit</tt> into a <tt>ResumableConduit</tt> with no
--   attached finalizer.
--   
--   Since 1.1.4
newResumableConduit :: Monad m => Conduit i m o -> ResumableConduit i m o

-- | Combines two sinks. The new sink will complete when both input sinks
--   have completed.
--   
--   Any leftovers are discarded.
--   
--   Since 0.4.1
zipSinks :: Monad m => Sink i m r -> Sink i m r' -> Sink i m (r, r')

-- | Combines two sources. The new source will stop producing once either
--   source has been exhausted.
--   
--   Since 1.0.13
zipSources :: Monad m => Source m a -> Source m b -> Source m (a, b)

-- | Combines two sources. The new source will stop producing once either
--   source has been exhausted.
--   
--   Since 1.0.13
zipSourcesApp :: Monad m => Source m (a -> b) -> Source m a -> Source m b

-- | Since 1.0.17
zipConduitApp :: Monad m => ConduitM i o m (x -> y) -> ConduitM i o m x -> ConduitM i o m y

-- | Merge a <tt>Source</tt> into a <tt>Conduit</tt>. The new conduit will
--   stop processing once either source or upstream have been exhausted.
mergeSource :: Monad m => Source m i -> Conduit a m (i, a)

-- | Turn a <tt>Sink</tt> into a <tt>Conduit</tt> in the following way:
--   
--   <ul>
--   <li>All input passed to the <tt>Sink</tt> is yielded downstream.</li>
--   <li>When the <tt>Sink</tt> finishes processing, the result is passed
--   to the provided to the finalizer function.</li>
--   </ul>
--   
--   Note that the <tt>Sink</tt> will stop receiving input as soon as the
--   downstream it is connected to shuts down.
--   
--   An example usage would be to write the result of a <tt>Sink</tt> to
--   some mutable variable while allowing other processing to continue.
--   
--   Since 1.1.0
passthroughSink :: Monad m => Sink i m r -> (r -> m ()) -> Conduit i m i

-- | Convert a <tt>Source</tt> into a list. The basic functionality can be
--   explained as:
--   
--   <pre>
--   sourceToList src = src $$ Data.Conduit.List.consume
--   </pre>
--   
--   However, <tt>sourceToList</tt> is able to produce its results lazily,
--   which cannot be done when running a conduit pipeline in general.
--   Unlike the <tt>Data.Conduit.Lazy</tt> module (in conduit-extra), this
--   function performs no unsafe I/O operations, and therefore can only be
--   as lazily as the underlying monad.
--   
--   Since 1.2.6
sourceToList :: Monad m => Source m a -> m [a]

-- | Fuse two <tt>ConduitM</tt>s together, and provide the return value of
--   both. Note that this will force the entire upstream <tt>ConduitM</tt>
--   to be run to produce the result value, even if the downstream
--   terminates early.
--   
--   Since 1.1.5
fuseBoth :: Monad m => ConduitM a b m r1 -> ConduitM b c m r2 -> ConduitM a c m (r1, r2)

-- | Like <a>fuseBoth</a>, but does not force consumption of the
--   <tt>Producer</tt>. In the case that the <tt>Producer</tt> terminates,
--   the result value is provided as a <tt>Just</tt> value. If it does not
--   terminate, then a <tt>Nothing</tt> value is returned.
--   
--   One thing to note here is that "termination" here only occurs if the
--   <tt>Producer</tt> actually yields a <tt>Nothing</tt> value. For
--   example, with the <tt>Producer</tt> <tt>mapM_ yield [1..5]</tt>, if
--   five values are requested, the <tt>Producer</tt> has not yet
--   terminated. Termination only occurs when the sixth value is awaited
--   for and the <tt>Producer</tt> signals termination.
--   
--   Since 1.2.4
fuseBothMaybe :: Monad m => ConduitM a b m r1 -> ConduitM b c m r2 -> ConduitM a c m (Maybe r1, r2)

-- | Same as <tt>fuseBoth</tt>, but ignore the return value from the
--   downstream <tt>Conduit</tt>. Same caveats of forced consumption apply.
--   
--   Since 1.1.5
fuseUpstream :: Monad m => ConduitM a b m r -> Conduit b m c -> ConduitM a c m r

-- | Coalesce all values yielded by all of the <tt>Source</tt>s.
--   
--   Implemented on top of <tt>ZipSource</tt>, see that data type for more
--   details.
--   
--   Since 1.0.13
sequenceSources :: (Traversable f, Monad m) => f (Source m o) -> Source m (f o)

-- | Send incoming values to all of the <tt>Sink</tt> providing, and
--   ultimately coalesce together all return values.
--   
--   Implemented on top of <tt>ZipSink</tt>, see that data type for more
--   details.
--   
--   Since 1.0.13
sequenceSinks :: (Traversable f, Monad m) => f (Sink i m r) -> Sink i m (f r)

-- | Provide identical input to all of the <tt>Conduit</tt>s and combine
--   their outputs into a single stream.
--   
--   Implemented on top of <tt>ZipConduit</tt>, see that data type for more
--   details.
--   
--   Since 1.0.17
sequenceConduits :: (Traversable f, Monad m) => f (ConduitM i o m r) -> ConduitM i o m (f r)


-- | If this is your first time with conduit, you should probably start
--   with the tutorial:
--   <a>https://haskell.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview</a>.
module Data.Conduit

-- | Provides a stream of output values, without consuming any input or
--   producing a final result.
--   
--   Since 0.5.0
type Source m o = ConduitM () o m ()

-- | Consumes a stream of input values and produces a stream of output
--   values, without producing a final result.
--   
--   Since 0.5.0
type Conduit i m o = ConduitM i o m ()

-- | Consumes a stream of input values and produces a final result, without
--   producing any output.
--   
--   <pre>
--   type Sink i m r = ConduitM i Void m r
--   </pre>
--   
--   Since 0.5.0
type Sink i = ConduitM i Void

-- | Core datatype of the conduit package. This type represents a general
--   component which can consume a stream of input values <tt>i</tt>,
--   produce a stream of output values <tt>o</tt>, perform actions in the
--   <tt>m</tt> monad, and produce a final result <tt>r</tt>. The type
--   synonyms provided here are simply wrappers around this type.
--   
--   Since 1.0.0
data ConduitM i o m r

-- | The connect operator, which pulls data from a source and pushes to a
--   sink. If you would like to keep the <tt>Source</tt> open to be used
--   for other operations, use the connect-and-resume operator <a>$$+</a>.
--   
--   Since 0.4.0
($$) :: Monad m => Source m a -> Sink a m b -> m b

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0
($=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0
(=$) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r

-- | Fusion operator, combining two <tt>Conduit</tt>s together into a new
--   <tt>Conduit</tt>.
--   
--   Both <tt>Conduit</tt>s will be closed when the newly-created
--   <tt>Conduit</tt> is closed.
--   
--   Leftover data returned from the right <tt>Conduit</tt> will be
--   discarded.
--   
--   Since 0.4.0
(=$=) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r

-- | Named function synonym for <a>$$</a>.
--   
--   Since 1.2.3
connect :: Monad m => Source m a -> Sink a m b -> m b

-- | Named function synonym for <a>=$=</a>.
--   
--   Since 1.2.3
fuse :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r

-- | Fuse two <tt>ConduitM</tt>s together, and provide the return value of
--   both. Note that this will force the entire upstream <tt>ConduitM</tt>
--   to be run to produce the result value, even if the downstream
--   terminates early.
--   
--   Since 1.1.5
fuseBoth :: Monad m => ConduitM a b m r1 -> ConduitM b c m r2 -> ConduitM a c m (r1, r2)

-- | Like <a>fuseBoth</a>, but does not force consumption of the
--   <tt>Producer</tt>. In the case that the <tt>Producer</tt> terminates,
--   the result value is provided as a <tt>Just</tt> value. If it does not
--   terminate, then a <tt>Nothing</tt> value is returned.
--   
--   One thing to note here is that "termination" here only occurs if the
--   <tt>Producer</tt> actually yields a <tt>Nothing</tt> value. For
--   example, with the <tt>Producer</tt> <tt>mapM_ yield [1..5]</tt>, if
--   five values are requested, the <tt>Producer</tt> has not yet
--   terminated. Termination only occurs when the sixth value is awaited
--   for and the <tt>Producer</tt> signals termination.
--   
--   Since 1.2.4
fuseBothMaybe :: Monad m => ConduitM a b m r1 -> ConduitM b c m r2 -> ConduitM a c m (Maybe r1, r2)

-- | Same as <tt>fuseBoth</tt>, but ignore the return value from the
--   downstream <tt>Conduit</tt>. Same caveats of forced consumption apply.
--   
--   Since 1.1.5
fuseUpstream :: Monad m => ConduitM a b m r -> Conduit b m c -> ConduitM a c m r

-- | Wait for a single input value from upstream. If no data is available,
--   returns <tt>Nothing</tt>. Once <tt>await</tt> returns
--   <tt>Nothing</tt>, subsequent calls will also return <tt>Nothing</tt>.
--   
--   Since 0.5.0
await :: Monad m => Consumer i m (Maybe i)

-- | Send a value downstream to the next component to consume. If the
--   downstream component terminates, this call will never return control.
--   If you would like to register a cleanup function, please use
--   <a>yieldOr</a> instead.
--   
--   Since 0.5.0
yield :: Monad m => o -> ConduitM i o m ()

-- | Provide a single piece of leftover input to be consumed by the next
--   component in the current monadic binding.
--   
--   <i>Note</i>: it is highly encouraged to only return leftover values
--   from input already consumed from upstream.
--   
--   Since 0.5.0
leftover :: i -> ConduitM i o m ()

-- | Run a pipeline until processing completes.
--   
--   Since 1.2.1
runConduit :: Monad m => ConduitM () Void m r -> m r

-- | Perform some allocation and run an inner component. Two guarantees are
--   given about resource finalization:
--   
--   <ol>
--   <li>It will be <i>prompt</i>. The finalization will be run as early as
--   possible.</li>
--   <li>It is exception safe. Due to usage of <tt>resourcet</tt>, the
--   finalization will be run in the event of any exceptions.</li>
--   </ol>
--   
--   Since 0.5.0
bracketP :: MonadResource m => IO a -> (a -> IO ()) -> (a -> ConduitM i o m r) -> ConduitM i o m r

-- | Add some code to be run when the given component cleans up.
--   
--   The supplied cleanup function will be given a <tt>True</tt> if the
--   component ran to completion, or <tt>False</tt> if it terminated early
--   due to a downstream component terminating.
--   
--   Note that this function is not exception safe. For that, please use
--   <a>bracketP</a>.
--   
--   Since 0.4.1
addCleanup :: Monad m => (Bool -> m ()) -> ConduitM i o m r -> ConduitM i o m r

-- | Similar to <a>yield</a>, but additionally takes a finalizer to be run
--   if the downstream component terminates.
--   
--   Since 0.5.0
yieldOr :: Monad m => o -> m () -> ConduitM i o m ()

-- | Catch all exceptions thrown by the current component of the pipeline.
--   
--   Note: this will <i>not</i> catch exceptions thrown by other
--   components! For example, if an exception is thrown in a
--   <tt>Source</tt> feeding to a <tt>Sink</tt>, and the <tt>Sink</tt> uses
--   <tt>catchC</tt>, the exception will <i>not</i> be caught.
--   
--   Due to this behavior (as well as lack of async exception handling),
--   you should not try to implement combinators such as
--   <tt>onException</tt> in terms of this primitive function.
--   
--   Note also that the exception handling will <i>not</i> be applied to
--   any finalizers generated by this conduit.
--   
--   Since 1.0.11
catchC :: (MonadBaseControl IO m, Exception e) => ConduitM i o m r -> (e -> ConduitM i o m r) -> ConduitM i o m r

-- | The same as <tt>flip catchC</tt>.
--   
--   Since 1.0.11
handleC :: (MonadBaseControl IO m, Exception e) => (e -> ConduitM i o m r) -> ConduitM i o m r -> ConduitM i o m r

-- | A version of <tt>try</tt> for use within a pipeline. See the comments
--   in <tt>catchC</tt> for more details.
--   
--   Since 1.0.11
tryC :: (MonadBaseControl IO m, Exception e) => ConduitM i o m r -> ConduitM i o m (Either e r)

-- | A component which produces a stream of output values, regardless of
--   the input stream. A <tt>Producer</tt> is a generalization of a
--   <tt>Source</tt>, and can be used as either a <tt>Source</tt> or a
--   <tt>Conduit</tt>.
--   
--   Since 1.0.0
type Producer m o = forall i. ConduitM i o m ()

-- | A component which consumes a stream of input values and produces a
--   final result, regardless of the output stream. A <tt>Consumer</tt> is
--   a generalization of a <tt>Sink</tt>, and can be used as either a
--   <tt>Sink</tt> or a <tt>Conduit</tt>.
--   
--   Since 1.0.0
type Consumer i m r = forall o. ConduitM i o m r

-- | Generalize a <a>Source</a> to a <a>Producer</a>.
--   
--   Since 1.0.0
toProducer :: Monad m => Source m a -> Producer m a

-- | Generalize a <a>Sink</a> to a <a>Consumer</a>.
--   
--   Since 1.0.0
toConsumer :: Monad m => Sink a m b -> Consumer a m b

-- | Wait for input forever, calling the given inner component for each
--   piece of new input. Returns the upstream result type.
--   
--   This function is provided as a convenience for the common pattern of
--   <tt>await</tt>ing input, checking if it's <tt>Just</tt> and then
--   looping.
--   
--   Since 0.5.0
awaitForever :: Monad m => (i -> ConduitM i o m r) -> ConduitM i o m ()

-- | Transform the monad that a <tt>ConduitM</tt> lives in.
--   
--   Note that the monad transforming function will be run multiple times,
--   resulting in unintuitive behavior in some cases. For a fuller
--   treatment, please see:
--   
--   
--   <a>https://github.com/snoyberg/conduit/wiki/Dealing-with-monad-transformers</a>
--   
--   This function is just a synonym for <a>hoist</a>.
--   
--   Since 0.4.0
transPipe :: Monad m => (forall a. m a -> n a) -> ConduitM i o m r -> ConduitM i o n r

-- | Apply a function to all the output values of a <tt>ConduitM</tt>.
--   
--   This mimics the behavior of <a>fmap</a> for a <a>Source</a> and
--   <a>Conduit</a> in pre-0.4 days. It can also be simulated by fusing
--   with the <tt>map</tt> conduit from <a>Data.Conduit.List</a>.
--   
--   Since 0.4.1
mapOutput :: Monad m => (o1 -> o2) -> ConduitM i o1 m r -> ConduitM i o2 m r

-- | Same as <a>mapOutput</a>, but use a function that returns
--   <tt>Maybe</tt> values.
--   
--   Since 0.5.0
mapOutputMaybe :: Monad m => (o1 -> Maybe o2) -> ConduitM i o1 m r -> ConduitM i o2 m r

-- | Apply a function to all the input values of a <tt>ConduitM</tt>.
--   
--   Since 0.5.0
mapInput :: Monad m => (i1 -> i2) -> (i2 -> Maybe i1) -> ConduitM i2 o m r -> ConduitM i1 o m r

-- | Merge a <tt>Source</tt> into a <tt>Conduit</tt>. The new conduit will
--   stop processing once either source or upstream have been exhausted.
mergeSource :: Monad m => Source m i -> Conduit a m (i, a)

-- | Turn a <tt>Sink</tt> into a <tt>Conduit</tt> in the following way:
--   
--   <ul>
--   <li>All input passed to the <tt>Sink</tt> is yielded downstream.</li>
--   <li>When the <tt>Sink</tt> finishes processing, the result is passed
--   to the provided to the finalizer function.</li>
--   </ul>
--   
--   Note that the <tt>Sink</tt> will stop receiving input as soon as the
--   downstream it is connected to shuts down.
--   
--   An example usage would be to write the result of a <tt>Sink</tt> to
--   some mutable variable while allowing other processing to continue.
--   
--   Since 1.1.0
passthroughSink :: Monad m => Sink i m r -> (r -> m ()) -> Conduit i m i

-- | Convert a <tt>Source</tt> into a list. The basic functionality can be
--   explained as:
--   
--   <pre>
--   sourceToList src = src $$ Data.Conduit.List.consume
--   </pre>
--   
--   However, <tt>sourceToList</tt> is able to produce its results lazily,
--   which cannot be done when running a conduit pipeline in general.
--   Unlike the <tt>Data.Conduit.Lazy</tt> module (in conduit-extra), this
--   function performs no unsafe I/O operations, and therefore can only be
--   as lazily as the underlying monad.
--   
--   Since 1.2.6
sourceToList :: Monad m => Source m a -> m [a]

-- | A <tt>Source</tt> which has been started, but has not yet completed.
--   
--   This type contains both the current state of the <tt>Source</tt>, and
--   the finalizer to be run to close it.
--   
--   Since 0.5.0
data ResumableSource m o

-- | Turn a <tt>Source</tt> into a <tt>ResumableSource</tt> with no
--   attached finalizer.
--   
--   Since 1.1.4
newResumableSource :: Monad m => Source m o -> ResumableSource m o

-- | The connect-and-resume operator. This does not close the
--   <tt>Source</tt>, but instead returns it to be used again. This allows
--   a <tt>Source</tt> to be used incrementally in a large program, without
--   forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Mnemonic: connect + do more.
--   
--   Since 0.5.0
($$+) :: Monad m => Source m a -> Sink a m b -> m (ResumableSource m a, b)

-- | Continue processing after usage of <tt>$$+</tt>.
--   
--   Since 0.5.0
($$++) :: Monad m => ResumableSource m a -> Sink a m b -> m (ResumableSource m a, b)

-- | Complete processing of a <tt>ResumableSource</tt>. This will run the
--   finalizer associated with the <tt>ResumableSource</tt>. In order to
--   guarantee process resource finalization, you <i>must</i> use this
--   operator after using <tt>$$+</tt> and <tt>$$++</tt>.
--   
--   Since 0.5.0
($$+-) :: Monad m => ResumableSource m a -> Sink a m b -> m b

-- | Left fusion for a resumable source.
--   
--   Since 1.0.16
($=+) :: Monad m => ResumableSource m a -> Conduit a m b -> ResumableSource m b

-- | Unwraps a <tt>ResumableSource</tt> into a <tt>Source</tt> and a
--   finalizer.
--   
--   A <tt>ResumableSource</tt> represents a <tt>Source</tt> which has
--   already been run, and therefore has a finalizer registered. As a
--   result, if we want to turn it into a regular <tt>Source</tt>, we need
--   to ensure that the finalizer will be run appropriately. By
--   appropriately, I mean:
--   
--   <ul>
--   <li>If a new finalizer is registered, the old one should not be
--   called.</li>
--   <li>If the old one is called, it should not be called again.</li>
--   </ul>
--   
--   This function returns both a <tt>Source</tt> and a finalizer which
--   ensures that the above two conditions hold. Once you call that
--   finalizer, the <tt>Source</tt> is invalidated and cannot be used.
--   
--   Since 0.5.2
unwrapResumable :: MonadIO m => ResumableSource m o -> m (Source m o, m ())

-- | Execute the finalizer associated with a <tt>ResumableSource</tt>,
--   rendering the <tt>ResumableSource</tt> invalid for further use.
--   
--   This is just a more explicit version of <tt>$$+- return ()</tt>.
--   
--   Since 1.1.3
closeResumableSource :: Monad m => ResumableSource m a -> m ()

-- | A generalization of <a>ResumableSource</a>. Allows to resume an
--   arbitrary conduit, keeping its state and using it later (or finalizing
--   it).
--   
--   Since 1.0.17
data ResumableConduit i m o

-- | Turn a <tt>Conduit</tt> into a <tt>ResumableConduit</tt> with no
--   attached finalizer.
--   
--   Since 1.1.4
newResumableConduit :: Monad m => Conduit i m o -> ResumableConduit i m o

-- | The connect-and-resume operator. This does not close the
--   <tt>Conduit</tt>, but instead returns it to be used again. This allows
--   a <tt>Conduit</tt> to be used incrementally in a large program,
--   without forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Leftover data returned from the <tt>Sink</tt> will be discarded.
--   
--   Mnemonic: connect + do more.
--   
--   Since 1.0.17
(=$$+) :: Monad m => Conduit a m b -> Sink b m r -> Sink a m (ResumableConduit a m b, r)

-- | Continue processing after usage of <a>=$$+</a>. Connect a
--   <a>ResumableConduit</a> to a sink and return the output of the sink
--   together with a new <a>ResumableConduit</a>.
--   
--   Since 1.0.17
(=$$++) :: Monad m => ResumableConduit i m o -> Sink o m r -> Sink i m (ResumableConduit i m o, r)

-- | Complete processing of a <a>ResumableConduit</a>. This will run the
--   finalizer associated with the <tt>ResumableConduit</tt>. In order to
--   guarantee process resource finalization, you <i>must</i> use this
--   operator after using <a>=$$+</a> and <a>=$$++</a>.
--   
--   Since 1.0.17
(=$$+-) :: Monad m => ResumableConduit i m o -> Sink o m r -> Sink i m r

-- | Unwraps a <tt>ResumableConduit</tt> into a <tt>Conduit</tt> and a
--   finalizer.
--   
--   Since <a>unwrapResumable</a> for more information.
--   
--   Since 1.0.17
unwrapResumableConduit :: MonadIO m => ResumableConduit i m o -> m (Conduit i m o, m ())

-- | Similar to <tt>fuseReturnLeftovers</tt>, but use the provided function
--   to convert downstream leftovers to upstream leftovers.
--   
--   Since 1.0.17
fuseLeftovers :: Monad m => ([b] -> [a]) -> ConduitM a b m () -> ConduitM b c m r -> ConduitM a c m r

-- | Same as normal fusion (e.g. <tt>=$=</tt>), except instead of
--   discarding leftovers from the downstream component, return them.
--   
--   Since 1.0.17
fuseReturnLeftovers :: Monad m => ConduitM a b m () -> ConduitM b c m r -> ConduitM a c m (r, [b])

-- | Provide for a stream of data that can be flushed.
--   
--   A number of <tt>Conduit</tt>s (e.g., zlib compression) need the
--   ability to flush the stream at some point. This provides a single
--   wrapper datatype to be used in all such circumstances.
--   
--   Since 0.3.0
data Flush a
Chunk :: a -> Flush a
Flush :: Flush a

-- | A wrapper for defining an <a>Applicative</a> instance for
--   <a>Source</a>s which allows to combine sources together, generalizing
--   <a>zipSources</a>. A combined source will take input yielded from each
--   of its <tt>Source</tt>s until any of them stop producing output.
--   
--   Since 1.0.13
newtype ZipSource m o
ZipSource :: Source m o -> ZipSource m o
[getZipSource] :: ZipSource m o -> Source m o

-- | Coalesce all values yielded by all of the <tt>Source</tt>s.
--   
--   Implemented on top of <tt>ZipSource</tt>, see that data type for more
--   details.
--   
--   Since 1.0.13
sequenceSources :: (Traversable f, Monad m) => f (Source m o) -> Source m (f o)

-- | A wrapper for defining an <a>Applicative</a> instance for <a>Sink</a>s
--   which allows to combine sinks together, generalizing <a>zipSinks</a>.
--   A combined sink distributes the input to all its participants and when
--   all finish, produces the result. This allows to define functions like
--   
--   <pre>
--   sequenceSinks :: (Monad m)
--             =&gt; [Sink i m r] -&gt; Sink i m [r]
--   sequenceSinks = getZipSink . sequenceA . fmap ZipSink
--   </pre>
--   
--   Note that the standard <a>Applicative</a> instance for conduits works
--   differently. It feeds one sink with input until it finishes, then
--   switches to another, etc., and at the end combines their results.
--   
--   This newtype is in fact a type constrained version of
--   <a>ZipConduit</a>, and has the same behavior. It's presented as a
--   separate type since (1) it historically predates <tt>ZipConduit</tt>,
--   and (2) the type constraining can make your code clearer (and thereby
--   make your error messages more easily understood).
--   
--   Since 1.0.13
newtype ZipSink i m r
ZipSink :: Sink i m r -> ZipSink i m r
[getZipSink] :: ZipSink i m r -> Sink i m r

-- | Send incoming values to all of the <tt>Sink</tt> providing, and
--   ultimately coalesce together all return values.
--   
--   Implemented on top of <tt>ZipSink</tt>, see that data type for more
--   details.
--   
--   Since 1.0.13
sequenceSinks :: (Traversable f, Monad m) => f (Sink i m r) -> Sink i m (f r)

-- | Provides an alternative <tt>Applicative</tt> instance for
--   <tt>ConduitM</tt>. In this instance, every incoming value is provided
--   to all <tt>ConduitM</tt>s, and output is coalesced together. Leftovers
--   from individual <tt>ConduitM</tt>s will be used within that component,
--   and then discarded at the end of their computation. Output and
--   finalizers will both be handled in a left-biased manner.
--   
--   As an example, take the following program:
--   
--   <pre>
--   main :: IO ()
--   main = do
--       let src = mapM_ yield [1..3 :: Int]
--           conduit1 = CL.map (+1)
--           conduit2 = CL.concatMap (replicate 2)
--           conduit = getZipConduit $ ZipConduit conduit1 &lt;* ZipConduit conduit2
--           sink = CL.mapM_ print
--       src $$ conduit =$ sink
--   </pre>
--   
--   It will produce the output: 2, 1, 1, 3, 2, 2, 4, 3, 3
--   
--   Since 1.0.17
newtype ZipConduit i o m r
ZipConduit :: ConduitM i o m r -> ZipConduit i o m r
[getZipConduit] :: ZipConduit i o m r -> ConduitM i o m r

-- | Provide identical input to all of the <tt>Conduit</tt>s and combine
--   their outputs into a single stream.
--   
--   Implemented on top of <tt>ZipConduit</tt>, see that data type for more
--   details.
--   
--   Since 1.0.17
sequenceConduits :: (Traversable f, Monad m) => f (ConduitM i o m r) -> ConduitM i o m (f r)


-- | Higher-level functions to interact with the elements of a stream. Most
--   of these are based on list functions.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
--   
--   Note that these functions all deal with individual elements of a
--   stream as a sort of "black box", where there is no introspection of
--   the contained elements. Values such as <tt>ByteString</tt> and
--   <tt>Text</tt> will likely need to be treated specially to deal with
--   their contents properly (<tt>Word8</tt> and <tt>Char</tt>,
--   respectively). See the <a>Data.Conduit.Binary</a> and
--   <a>Data.Conduit.Text</a> modules.
module Data.Conduit.List

-- | Yield the values from the list.
--   
--   Subject to fusion
sourceList :: Monad m => [a] -> Producer m a

-- | A source that outputs no values. Note that this is just a
--   type-restricted synonym for <a>mempty</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
sourceNull :: Monad m => Producer m a

-- | Generate a source from a seed value.
--   
--   Subject to fusion
--   
--   Since 0.4.2
unfold :: Monad m => (b -> Maybe (a, b)) -> b -> Producer m a

-- | A monadic unfold.
--   
--   Subject to fusion
--   
--   Since 1.1.2
unfoldM :: Monad m => (b -> m (Maybe (a, b))) -> b -> Producer m a

-- | Enumerate from a value to a final value, inclusive, via <tt>succ</tt>.
--   
--   This is generally more efficient than using <tt>Prelude</tt>'s
--   <tt>enumFromTo</tt> and combining with <tt>sourceList</tt> since this
--   avoids any intermediate data structures.
--   
--   Subject to fusion
--   
--   Since 0.4.2
enumFromTo :: (Enum a, Ord a, Monad m) => a -> a -> Producer m a

-- | Produces an infinite stream of repeated applications of f to x.
--   
--   Subject to fusion
iterate :: Monad m => (a -> a) -> a -> Producer m a

-- | Replicate a single value the given number of times.
--   
--   Subject to fusion
--   
--   Since 1.2.0
replicate :: Monad m => Int -> a -> Producer m a

-- | Replicate a monadic value the given number of times.
--   
--   Subject to fusion
--   
--   Since 1.2.0
replicateM :: Monad m => Int -> m a -> Producer m a

-- | A strict left fold.
--   
--   Subject to fusion
--   
--   Since 0.3.0
fold :: Monad m => (b -> a -> b) -> b -> Consumer a m b

-- | A monoidal strict left fold.
--   
--   Subject to fusion
--   
--   Since 0.5.3
foldMap :: (Monad m, Monoid b) => (a -> b) -> Consumer a m b

-- | Take some values from the stream and return as a list. If you want to
--   instead create a conduit that pipes data to another sink, see
--   <a>isolate</a>. This function is semantically equivalent to:
--   
--   <pre>
--   take i = isolate i =$ consume
--   </pre>
--   
--   Subject to fusion
--   
--   Since 0.3.0
take :: Monad m => Int -> Consumer a m [a]

-- | Ignore a certain number of values in the stream. This function is
--   semantically equivalent to:
--   
--   <pre>
--   drop i = take i &gt;&gt; return ()
--   </pre>
--   
--   However, <tt>drop</tt> is more efficient as it does not need to hold
--   values in memory.
--   
--   Subject to fusion
--   
--   Since 0.3.0
drop :: Monad m => Int -> Consumer a m ()

-- | Take a single value from the stream, if available.
--   
--   Subject to fusion
--   
--   Since 0.3.0
head :: Monad m => Consumer a m (Maybe a)

-- | Look at the next value in the stream, if available. This function will
--   not change the state of the stream.
--   
--   Since 0.3.0
peek :: Monad m => Consumer a m (Maybe a)

-- | Consume all values from the stream and return as a list. Note that
--   this will pull all values into memory. For a lazy variant, see
--   <a>Data.Conduit.Lazy</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
consume :: Monad m => Consumer a m [a]

-- | Ignore the remainder of values in the source. Particularly useful when
--   combined with <a>isolate</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
sinkNull :: Monad m => Consumer a m ()

-- | A monoidal strict left fold in a Monad.
--   
--   Since 1.0.8
foldMapM :: (Monad m, Monoid b) => (a -> m b) -> Consumer a m b

-- | A monadic strict left fold.
--   
--   Subject to fusion
--   
--   Since 0.3.0
foldM :: Monad m => (b -> a -> m b) -> b -> Consumer a m b

-- | Apply the action to all values in the stream.
--   
--   Subject to fusion
--   
--   Since 0.3.0
mapM_ :: Monad m => (a -> m ()) -> Consumer a m ()

-- | Apply a transformation to all values in a stream.
--   
--   Subject to fusion
--   
--   Since 0.3.0
map :: Monad m => (a -> b) -> Conduit a m b

-- | Apply a transformation that may fail to all values in a stream,
--   discarding the failures.
--   
--   Subject to fusion
--   
--   Since 0.5.1
mapMaybe :: Monad m => (a -> Maybe b) -> Conduit a m b

-- | Generalization of <a>mapMaybe</a> and <a>concatMap</a>. It applies
--   function to all values in a stream and send values inside resulting
--   <tt>Foldable</tt> downstream.
--   
--   Subject to fusion
--   
--   Since 1.0.6
mapFoldable :: (Monad m, Foldable f) => (a -> f b) -> Conduit a m b

-- | Filter the <tt>Just</tt> values from a stream, discarding the
--   <tt>Nothing</tt> values.
--   
--   Subject to fusion
--   
--   Since 0.5.1
catMaybes :: Monad m => Conduit (Maybe a) m a

-- | Generalization of <a>catMaybes</a>. It puts all values from
--   <a>Foldable</a> into stream.
--   
--   Subject to fusion
--   
--   Since 1.0.6
concat :: (Monad m, Foldable f) => Conduit (f a) m a

-- | Apply a transformation to all values in a stream, concatenating the
--   output values.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMap :: Monad m => (a -> [b]) -> Conduit a m b

-- | <a>concatMap</a> with a strict accumulator.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMapAccum :: Monad m => (a -> accum -> (accum, [b])) -> accum -> Conduit a m b

-- | Deprecated synonym for <tt>mapAccum</tt>
--   
--   Since 1.0.6

-- | <i>Deprecated: Use mapAccum instead</i>
scanl :: Monad m => (a -> s -> (s, b)) -> s -> Conduit a m b

-- | Analog of <a>scanl</a> for lists.
--   
--   Subject to fusion
--   
--   Since 1.1.1
scan :: Monad m => (a -> b -> b) -> b -> ConduitM a b m b

-- | Analog of <tt>mapAccumL</tt> for lists. Note that in contrast to
--   <tt>mapAccumL</tt>, the function argument takes the accumulator as its
--   second argument, not its first argument, and the accumulated value is
--   strict.
--   
--   Subject to fusion
--   
--   Since 1.1.1
mapAccum :: Monad m => (a -> s -> (s, b)) -> s -> ConduitM a b m s

-- | Grouping input according to an equality function.
--   
--   Subject to fusion
--   
--   Since 0.3.0
groupBy :: Monad m => (a -> a -> Bool) -> Conduit a m [a]

-- | <a>groupOn1</a> is similar to <tt>groupBy id</tt>
--   
--   returns a pair, indicating there are always 1 or more items in the
--   grouping. This is designed to be converted into a NonEmpty structure
--   but it avoids a dependency on another package
--   
--   <pre>
--   import Data.List.NonEmpty
--   
--   groupOn1 :: (Monad m, Eq b) =&gt; (a -&gt; b) -&gt; Conduit a m (NonEmpty a)
--   groupOn1 f = CL.groupOn1 f =$= CL.map (uncurry (:|))
--   </pre>
--   
--   Subject to fusion
--   
--   Since 1.1.7
groupOn1 :: (Monad m, Eq b) => (a -> b) -> Conduit a m (a, [a])

-- | Ensure that the inner sink consumes no more than the given number of
--   values. Note this this does <i>not</i> ensure that the sink consumes
--   all of those values. To get the latter behavior, combine with
--   <a>sinkNull</a>, e.g.:
--   
--   <pre>
--   src $$ do
--       x &lt;- isolate count =$ do
--           x &lt;- someSink
--           sinkNull
--           return x
--       someOtherSink
--       ...
--   </pre>
--   
--   Subject to fusion
--   
--   Since 0.3.0
isolate :: Monad m => Int -> Conduit a m a

-- | Keep only values in the stream passing a given predicate.
--   
--   Subject to fusion
--   
--   Since 0.3.0
filter :: Monad m => (a -> Bool) -> Conduit a m a

-- | Apply a monadic transformation to all values in a stream.
--   
--   If you do not need the transformed values, and instead just want the
--   monadic side-effects of running the action, see <a>mapM_</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
mapM :: Monad m => (a -> m b) -> Conduit a m b

-- | Apply a monadic action on all values in a stream.
--   
--   This <tt>Conduit</tt> can be used to perform a monadic side-effect for
--   every value, whilst passing the value through the <tt>Conduit</tt>
--   as-is.
--   
--   <pre>
--   iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)
--   </pre>
--   
--   Subject to fusion
--   
--   Since 0.5.6
iterM :: Monad m => (a -> m ()) -> Conduit a m a

-- | Deprecated synonym for <tt>mapAccumM</tt>
--   
--   Since 1.0.6

-- | <i>Deprecated: Use mapAccumM instead</i>
scanlM :: Monad m => (a -> s -> m (s, b)) -> s -> Conduit a m b

-- | Monadic <tt>scanl</tt>.
--   
--   Subject to fusion
--   
--   Since 1.1.1
scanM :: Monad m => (a -> b -> m b) -> b -> ConduitM a b m b

-- | Monadic <a>mapAccum</a>.
--   
--   Subject to fusion
--   
--   Since 1.1.1
mapAccumM :: Monad m => (a -> s -> m (s, b)) -> s -> ConduitM a b m s

-- | Apply a monadic transformation that may fail to all values in a
--   stream, discarding the failures.
--   
--   Subject to fusion
--   
--   Since 0.5.1
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> Conduit a m b

-- | Monadic variant of <a>mapFoldable</a>.
--   
--   Subject to fusion
--   
--   Since 1.0.6
mapFoldableM :: (Monad m, Foldable f) => (a -> m (f b)) -> Conduit a m b

-- | Apply a monadic transformation to all values in a stream,
--   concatenating the output values.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMapM :: Monad m => (a -> m [b]) -> Conduit a m b

-- | <a>concatMapM</a> with a strict accumulator.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMapAccumM :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> Conduit a m b

-- | Run a <tt>Pipe</tt> repeatedly, and output its result value
--   downstream. Stops when no more input is available from upstream.
--   
--   Since 0.5.0
sequence :: Monad m => Consumer i m o -> Conduit i m o


-- | Allow monad transformers to be run/eval/exec in a section of conduit
--   rather then needing to run across the whole conduit. The circumvents
--   many of the problems with breaking the monad transformer laws. For
--   more information, see the announcement blog post:
--   <a>http://www.yesodweb.com/blog/2014/01/conduit-transformer-exception</a>
--   
--   This module was added in conduit 1.0.11.
module Data.Conduit.Lift

-- | Wrap the base monad in <a>ErrorT</a>
--   
--   Since 1.0.11
errorC :: (Monad m, Monad (t (ErrorT e m)), MonadTrans t, Error e, MFunctor t) => t m (Either e b) -> t (ErrorT e m) b

-- | Run <a>ErrorT</a> in the base monad
--   
--   Since 1.0.11
runErrorC :: (Monad m, Error e) => ConduitM i o (ErrorT e m) r -> ConduitM i o m (Either e r)

-- | Catch an error in the base monad
--   
--   Since 1.0.11
catchErrorC :: (Monad m, Error e) => ConduitM i o (ErrorT e m) r -> (e -> ConduitM i o (ErrorT e m) r) -> ConduitM i o (ErrorT e m) r

-- | Run <a>CatchT</a> in the base monad
--   
--   Since 1.1.0
runCatchC :: Monad m => ConduitM i o (CatchT m) r -> ConduitM i o m (Either SomeException r)

-- | Catch an exception in the base monad
--   
--   Since 1.1.0
catchCatchC :: Monad m => ConduitM i o (CatchT m) r -> (SomeException -> ConduitM i o (CatchT m) r) -> ConduitM i o (CatchT m) r

-- | Wrap the base monad in <a>MaybeT</a>
--   
--   Since 1.0.11
maybeC :: (Monad m, Monad (t (MaybeT m)), MonadTrans t, MFunctor t) => t m (Maybe b) -> t (MaybeT m) b

-- | Run <a>MaybeT</a> in the base monad
--   
--   Since 1.0.11
runMaybeC :: Monad m => ConduitM i o (MaybeT m) r -> ConduitM i o m (Maybe r)

-- | Wrap the base monad in <a>ReaderT</a>
--   
--   Since 1.0.11
readerC :: (Monad m, Monad (t1 (ReaderT t m)), MonadTrans t1, MFunctor t1) => (t -> t1 m b) -> t1 (ReaderT t m) b

-- | Run <a>ReaderT</a> in the base monad
--   
--   Since 1.0.11
runReaderC :: Monad m => r -> ConduitM i o (ReaderT r m) res -> ConduitM i o m res

-- | Wrap the base monad in <a>StateT</a>
--   
--   Since 1.0.11
stateLC :: (Monad m, Monad (t1 (StateT t m)), MonadTrans t1, MFunctor t1) => (t -> t1 m (b, t)) -> t1 (StateT t m) b

-- | Run <a>StateT</a> in the base monad
--   
--   Since 1.0.11
runStateLC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m (r, s)

-- | Evaluate <a>StateT</a> in the base monad
--   
--   Since 1.0.11
evalStateLC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m r

-- | Execute <a>StateT</a> in the base monad
--   
--   Since 1.0.11
execStateLC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m s

-- | Wrap the base monad in <a>StateT</a>
--   
--   Since 1.0.11
stateC :: (Monad m, Monad (t1 (StateT t m)), MonadTrans t1, MFunctor t1) => (t -> t1 m (b, t)) -> t1 (StateT t m) b

-- | Run <a>StateT</a> in the base monad
--   
--   Since 1.0.11
runStateC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m (r, s)

-- | Evaluate <a>StateT</a> in the base monad
--   
--   Since 1.0.11
evalStateC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m r

-- | Execute <a>StateT</a> in the base monad
--   
--   Since 1.0.11
execStateC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m s

-- | Wrap the base monad in <a>WriterT</a>
--   
--   Since 1.0.11
writerLC :: (Monad m, Monad (t (WriterT w m)), MonadTrans t, Monoid w, MFunctor t) => t m (b, w) -> t (WriterT w m) b

-- | Run <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
runWriterLC :: (Monad m, Monoid w) => ConduitM i o (WriterT w m) r -> ConduitM i o m (r, w)

-- | Execute <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
execWriterLC :: (Monad m, Monoid w) => ConduitM i o (WriterT w m) r -> ConduitM i o m w

-- | Wrap the base monad in <a>WriterT</a>
--   
--   Since 1.0.11
writerC :: (Monad m, Monad (t (WriterT w m)), MonadTrans t, Monoid w, MFunctor t) => t m (b, w) -> t (WriterT w m) b

-- | Run <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
runWriterC :: (Monad m, Monoid w) => ConduitM i o (WriterT w m) r -> ConduitM i o m (r, w)

-- | Execute <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
execWriterC :: (Monad m, Monoid w) => ConduitM i o (WriterT w m) r -> ConduitM i o m w

-- | Wrap the base monad in <a>RWST</a>
--   
--   Since 1.0.11
rwsLC :: (Monad m, Monad (t1 (RWST t w t2 m)), MonadTrans t1, Monoid w, MFunctor t1) => (t -> t2 -> t1 m (b, t2, w)) -> t1 (RWST t w t2 m) b

-- | Run <a>RWST</a> in the base monad
--   
--   Since 1.0.11
runRWSLC :: (Monad m, Monoid w) => r -> s -> ConduitM i o (RWST r w s m) res -> ConduitM i o m (res, s, w)

-- | Evaluate <a>RWST</a> in the base monad
--   
--   Since 1.0.11
evalRWSLC :: (Monad m, Monoid w) => r -> s -> ConduitM i o (RWST r w s m) res -> ConduitM i o m (res, w)

-- | Execute <a>RWST</a> in the base monad
--   
--   Since 1.0.11
execRWSLC :: (Monad m, Monoid w) => r -> s -> ConduitM i o (RWST r w s m) res -> ConduitM i o m (s, w)

-- | Wrap the base monad in <a>RWST</a>
--   
--   Since 1.0.11
rwsC :: (Monad m, Monad (t1 (RWST t w t2 m)), MonadTrans t1, Monoid w, MFunctor t1) => (t -> t2 -> t1 m (b, t2, w)) -> t1 (RWST t w t2 m) b

-- | Run <a>RWST</a> in the base monad
--   
--   Since 1.0.11
runRWSC :: (Monad m, Monoid w) => r -> s -> ConduitM i o (RWST r w s m) res -> ConduitM i o m (res, s, w)

-- | Evaluate <a>RWST</a> in the base monad
--   
--   Since 1.0.11
evalRWSC :: (Monad m, Monoid w) => r -> s -> ConduitM i o (RWST r w s m) res -> ConduitM i o m (res, w)

-- | Execute <a>RWST</a> in the base monad
--   
--   Since 1.0.11
execRWSC :: (Monad m, Monoid w) => r -> s -> ConduitM i o (RWST r w s m) res -> ConduitM i o m (s, w)
distribute :: (Monad (t (ConduitM b o m)), Monad m, Monad (t m), MonadTrans t, MFunctor t) => ConduitM b o (t m) () -> t (ConduitM b o m) ()
